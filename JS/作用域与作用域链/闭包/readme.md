<!--
 * @Author       : BigDgreen
 * @Date         : 2020-07-16 21:32:37
 * @LastEditors  : BigDgreen
 * @LastEditTime : 2020-07-30 10:48:00
 * @FilePath     : \前端知识点总结\JS\闭包\readme.md
--> 
从实践角度，以下函数才算闭包：（狭义）
1. 即使创建它的上下文已经销毁，它依然存在（比如，内部函数从父函数中返回）
2. 在代码中引用了自由变量

js闭包是堆引用


1. 闭包是一个可以访问外部作用域中变量的内部函数。

2. 这些被引用的变量直到闭包被销毁时才会被销毁。

3. 闭包使得 timer 定时器，事件处理，AJAX 请求等异步任务更加容易。

4. 可以通过闭包来达到封装性。

当你在**原型链**（prototype chain）中找不到一个属性的时候，并不会引发一个错误，而是会得到undefined。但是如果你试图访问一个**作用域链**中不存在的属性的话，你就会得到一个ReferenceError。

以下是个人理解：

闭包的实质：

当闭包函数中使用某一变量时，在闭包函数作用域中没有找到，就去`[[scope]]`上查找，`[[scope]]`上存储的有父级函数的`AO`，`AO`对象中有变量声明。如果父级AO上没有找到变量，就继续沿着作用域链找，直到找到全局作用域，如果最后没有找到，就抛出`ReferenceError`。

当外层函数执行完毕后，从执行栈中弹出，但内层函数的执行上下文维护了一个作用域链（Scope），作用域链中有对外层函数的引用，因此不会被当成垃圾回收。



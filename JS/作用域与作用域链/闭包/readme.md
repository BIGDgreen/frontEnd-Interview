<!--
 * @Author       : BigDgreen
 * @Date         : 2020-07-16 21:32:37
 * @LastEditors  : BigDgreen
 * @LastEditTime : 2020-08-15 21:14:14
 * @FilePath     : \前端知识点总结\JS\作用域与作用域链\闭包\readme.md
--> 
从实践角度，以下函数才算闭包：（狭义）
1. 即使创建它的上下文已经销毁，它依然存在（比如，内部函数从父函数中返回）
2. 在代码中引用了自由变量

js闭包是堆引用


1. 闭包是一个可以访问外部作用域中变量的内部函数。

2. 这些被引用的变量直到闭包被销毁时才会被销毁。

3. 闭包使得 timer 定时器，事件处理，AJAX 请求等异步任务更加容易。

4. 可以通过闭包来达到封装性。

当你在**原型链**（prototype chain）中找不到一个属性的时候，并不会引发一个错误，而是会得到undefined。但是如果你试图访问一个**作用域链**中不存在的属性的话，你就会得到一个ReferenceError。

在 JavaScript 中，根据词法作用域的规则，内部函数总是可以访问其外部函数中声明的变量，当通过调用一个外部函数返回一个内部函数后，即使该外部函数已经执行结束了，但是内部函数引用外部函数的变量依然保存在内存中，我们就把这些变量的集合称为闭包。比如外部函数是 foo，那么这些变量的集合就称为 foo 函数的闭包。

当前执行上下文 –> 函数闭包 –> 全局执行上下文

以下是个人理解：

闭包的实质：

当闭包函数中使用某一变量时，在闭包函数作用域中没有找到，就去`[[scope]]`上查找，`[[scope]]`上存储的有父级函数的`AO`，`AO`对象中有变量声明。如果父级AO上没有找到变量，就继续沿着作用域链找，直到找到全局作用域，如果最后没有找到，就抛出`ReferenceError`。

当外层函数执行完毕后，从执行栈中弹出，但内层函数的执行上下文维护了一个作用域链（Scope），作用域链中有对外层函数的引用，因此不会被当成垃圾回收。


通常，如果引用闭包的函数是一个全局变量，那么闭包会一直存在直到页面关闭；但如果这个闭包以后不再使用的话，就会造成内存泄漏。

如果引用闭包的函数是个局部变量，等函数销毁后，在下次 JavaScript 引擎执行垃圾回收时，判断闭包这块内容如果已经不再被使用了，那么 JavaScript 引擎的垃圾回收器就会回收这块内存。

所以在使用闭包的时候，你要尽量注意一个原则：如果该闭包会一直使用，那么它可以作为全局变量而存在；但如果使用频率不高，而且占用内存又比较大的话，那就尽量让它成为一个局部变量。
